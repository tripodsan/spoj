/* global readline, print */

/*
  Algorithm: raycast the bulk from 1 side. whenever the ray intersects with a face it changes
  from outside to inside and vice versa. count the 'voxels' that are inside. it doesn't matter
  in which direction we raycast, for simplicity, we choose the Z-axis.
  Since the edges of the faces are parallel to an axis, we don't need to raycast every voxel,
  but only need to consider the face boundaries. to do so, we sort the X and Y coordinates of all
  vertices, make them unique and only need to scan all the rectangles generated by that grid.
  To check if a point is inside a face we do a 2d ray cast. again, since all edges are parallel to
  an axis, we can just check if it will intersect any of the edges in 1 direction. here we choose
  the edges that are parallel to Y, so where the X > as px.
 */

function createFace(points) {
  // we only consider the faces on the XY plane
  const z = points[2];
  for (let i = 5; i < points.length; i += 3) {
    if (points[i] !== z) {
      return null;
    }
  }
  // add the first point again to simplify the edge generation
  points.push(points[0], points[1], points[2]);
  const face = {
    z,
    edges: [],
  }
  let lastX = points[0];
  let lastY = points[1];
  let lastEdge;
  for (let k = 3; k < points.length; k += 3) {
    const x = points[k];
    const y = points[k + 1];
    if (y === lastY) {
      if (lastEdge) {
        // extend last edge
        lastEdge.x1 = x;
      } else {
        lastEdge = {
          y,
          x0: lastX,
          x1: x,
        }
        face.edges.push(lastEdge);
      }
    } else {
      lastEdge = null;
    }
    lastX = x;
    lastY = y;
  }
  // sort edges by Y
  face.edges.sort((e0, e1) => e0.y - e1.y);
  // sort x of edges
  for (const e of face.edges) {
    if (e.x0 > e.x1) {
      let t = e.x0;
      e.x0 = e.x1;
      e.x1 = t;
    }
  }
  return face;
}

function contains(f, x, y) {
  let polarity = 0;
  for (const e of f.edges) {
    if (e.y >= y && x >= e.x0 && x <= e.x1) {
      polarity = 1 - polarity;
    }
  }
  return polarity === 1;
}

const numBulks = parseInt(readline(), 10);
for (let i = 0; i < numBulks; i++) {
  const numFaces = parseInt(readline(), 10);
  let xCords = new Set();
  let yCords = new Set();
  const faces = [];
  for (let j = 0; j < numFaces; j++) {
    const points = readline().split(/\s+/).map((d) => parseInt(d, 10));
    points.shift(); // discard 'numPoints'
    const face = createFace(points);
    if (face) {
      faces.push(face);
      for (const e of face.edges) {
        xCords.add(e.x0);
        xCords.add(e.x1);
        yCords.add(e.y);
      }
    }
  }
  // sort faces by Y
  faces.sort((f0, f1) => f0.z - f1.z);
  // sort x and y cords
  xCords = [...xCords.values()].sort((x0, x1) => x0 - x1);
  yCords = [...yCords.values()].sort((y0, y1) => y0 - y1);

  let sum = 0;
  for (let j = 0; j < xCords.length - 1; j++) {
    const x = xCords[j] + 0.5; // since the voxel resolution is 1, we just raycast a bit off the corner point
    for (let k = 0; k < yCords.length - 1; k++) {
      const y = yCords[k] + 0.5;
      const area = (xCords[j + 1] - xCords[j]) * (yCords[k + 1] - yCords[k]); // size of "ray"
      let outside = true;
      let lastZ = Number.MIN_SAFE_INTEGER;
      let fi = 0;
      for (const f of faces) {
        if (f.z > lastZ && contains(f, x, y)) {
          // switch polarity
          outside = !outside;
          // if the ray is now outside again, add the number of traveled voxels
          if (outside) {
            sum += area * (f.z - lastZ);
          }
          lastZ = f.z;
        }
      }
    }
  }
  print(`The bulk is composed of ${sum} units.`);
}
